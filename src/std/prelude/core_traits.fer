/// Clamps a value between a minimum and maximum bound, inclusively.
fn clamp(value, min_bound, max_bound) {
	if min_bound > max_bound {
		panic("min_bound must be less than or equal to max_bound")
	} else {
		max(min_bound, min(value, max_bound))
	}
}

// Ranges

// /// A range bounded inclusively at start and exclusively at end: [start..end)
struct Range {
	start: int,
	end: int,
}

struct RangeIterator {
	range: Range,
	next: int,
}

impl Iterator {
	fn next(it: &mut RangeIterator) {
		let next = it.next;
		if it.range.end >= it.range.start {
			if it.next < it.range.end {
				it.next += 1;
				Some(next)
			} else {
				None
			}
		} else {
			if it.next > it.range.end {
				it.next -= 1;
				Some(next)
			} else {
				None
			}
		}
	}
}

impl Seq {
	fn iter(r: Range) {
		RangeIterator { range: r, next: r.start }
	}
}

impl SizedSeq {
	fn len(r: Range) {
		abs(r.end - r.start)
	}
}

fn range(start: int, end: int) {
	Range { start: start, end: end }
}

// Arrays

/// Return the last element of an array, or None if the array is empty.
fn array_peek_back(array) -> None | Some(_) {
    let l = array_len(array);
    if l <= 0 {
        None
    } else {
        Some(array[l - 1])
    }
}

/// Maps a function over an array, returning a new array with the results.
fn array_map(array: [_], f) {
	let mut result = [];
	for a in array {
		array_append(result, f(a));
	};
	result
}

impl Concat {
	fn concat(left, right) {
		array_concat(left, right)
	}
}

impl Cast {
	fn cast(array) {
		array_map(array, |element| cast(element))
	}
}

// Strings

impl Concat {
	fn concat(left, right) {
		string_concat(left, right)
	}
}

// Sequence and reduction functions

/// Returns true if the collection contains no elements.
fn is_empty(seq) {
	len(seq) == 0
}

/// Reduces the sequence seq to a single value by repeatedly applying f, left to right.
fn fold(seq, init, f) {
	let mut it = iter(seq);
	let mut acc = init;
	loop {
		match next(it) {
			Some(element) => {
				acc = f(acc, element);
			},
			None => soft_break,
		}
	};
	acc
}

/// Reduces the sequence seq to a single value by repeatedly applying f, left to right, as long as f returns Continue.
fn try_fold(seq, init, f) {
	let mut it = iter(seq);
	let mut acc = init;
	loop {
		match next(it) {
			Some(element) => {
				match f(acc, element) {
					Continue(value) => {
						acc = value;
					},
					// Note: we do not have residuals here because it would result in an unbound generic.
					// If we had a ControlFlow enum newtype with default generics, we could have residuals.
					Break => {
						return Break;
					}
				}
			},
			None => soft_break,
		}
	};
	Continue(acc)
}

/// Tests if every element of the sequence matches a predicate.
fn all(seq, f) {
	try_fold(seq, (), |_acc, element| if f(element) { Continue(()) } else { Break }) == Continue(())
}

/// Tests if any element of the sequence matches a predicate.
fn any(seq, f) {
	try_fold(seq, (), |_acc, element| if f(element) { Break } else { Continue(()) }) == Break
}

/// Counts the number of elements in the sequence.
fn count(seq) {
	fold(seq, 0, |sum, _element| sum + 1)
}

/// Sums the elements in the sequence.
fn sum(seq) {
	fold(seq, 0, |acc, element| acc + element)
}

/// Averages the elements in the sequence.
fn average(seq) {
	sum(seq) / count(seq)
}

/// Returns the minimum element in the sequence.
fn minimum(seq) {
	let mut it = iter(seq);
	match next(it) {
		Some(first) => {
			fold(it, first, |min_so_far, element| min(min_so_far, element))
		},
		None => panic("minimum of empty sequence"),
	}
}

/// Returns the maximum element in the sequence.
fn maximum(seq) {
	let mut it = iter(seq);
	match next(it) {
		Some(first) => {
			fold(it, first, |max_so_far, element| max(max_so_far, element))
		},
		None => panic("maximum of empty sequence"),
	}
}

/// Finds the first element in the sequence that matches a predicate, returning None if not found.
fn find(seq, predicate) -> None | Some(_) {
	let mut it = iter(seq);
	loop {
		match next(it) {
			Some(element) => {
				if predicate(element) {
					return Some(element);
				}
			},
			None => soft_break,
		}
	};
	None
}

/// Finds the position of the first element in the sequence that matches a predicate, returning None if not found.
fn position(seq, predicate) -> None | Some(int) {
	let mut it = iter(seq);
	let mut index = 0;
	loop {
		match next(it) {
			Some(element) => {
				if predicate(element) {
					return Some(index);
				};
				index = index + 1;
			},
			None => soft_break,
		}
	};
	None
}

// Compatibility, mark as deprecated when supported

/// Deprecated, use `all` instead.
fn array_all(array: [_], f) {
	all(array, f)
}

/// Deprecated, use `any` instead.
fn array_any(array: [_], f) {
	any(array, f)
}

// Iterator and Seq for string

impl Iterator {
	fn next(s) {
		string_iterator_next(s)
	}
}
impl Seq {
	fn iter(s) {
		string_iter(s)
	}
}
impl SizedSeq {
	fn len(s) {
		string_len(s)
	}
}

// Iterator and Seq for array
impl Iterator {
	fn next(a) {
		array_iterator_next(a)
	}
}
impl Seq {
	fn iter(a) {
		array_iter(a)
	}
}
// Requires per trait method generics
// impl FromIterator {
//     fn from_iter(it) {
//         let mut it = it;
//         let mut a = [];
//         loop {
//             match next(it) {
//                 Some(x) => {
//                     array_append(a, x);
//                 },
//                 None => soft_break,
//             }
//         };
//         a
//     }
// }
impl SizedSeq {
	fn len(a) {
		array_len(a)
	}
}

// Serde for basic types

/// Downcasts a variant to None, panicking if the variant is not None.
fn variant_to_none(v: Variant) -> () {
	match (v) {
		None => (),
		Array(a) => {
			if array_len(a) == 0 {
				()
			} else {
				panic("Expected array of size 0")
			}
		},
		_ => panic(f"Expected None variant or Array variant of size 0, got \"{v}\"")
	}
}
/// Downcasts a variant to a bool, panicking if the variant is not a bool.
fn variant_to_bool(v: Variant) {
	match (v) {
		Bool(b) => b,
		_ => panic(f"Expected Bool variant, got \"{v}\"")
	}
}
/// Downcasts a variant to an int, panicking if the variant is not an int or a float.
fn variant_to_int(v: Variant) {
	match (v) {
		Int(i) => i,
		Float(f) => round(f),
		_ => panic(f"Expected Int variant, got \"{v}\"")
	}
}
/// Downcasts a variant to a float, panicking if the variant is not a float or int.
fn variant_to_float(v: Variant) {
	match (v) {
		Float(f) => f,
		Int(i) => from_int(i),
		_ => panic(f"Expected Float or Int variant, got \"{v}\"")
	}
}
/// Downcasts a variant to a string, panicking if the variant is not a string.
fn variant_to_string(v: Variant) {
	match (v) {
		String(s) => s,
		_ => panic(f"Expected String variant, got \"{v}\"")
	}
}
/// Downcasts a variant to an array, panicking if the variant is not an array.
fn variant_to_array(v: Variant) {
	match (v) {
		Array(a) => a,
		_ => panic(f"Expected Array variant, got \"{v}\"")
	}
}
/// Downcasts a variant to an object payload, panicking if the variant is not an object.
fn variant_to_object(v: Variant) {
	match (v) {
		Object(o) => o,
		_ => panic(f"Expected Object variant, got \"{v}\"")
	}
}

impl Serialize {
	fn serialize(v: ()) {
		None
	}
}
impl Deserialize {
	fn deserialize(v) -> () {
		variant_to_none(v)
	}
}
impl Serialize {
	fn serialize(v: bool) {
		Bool(v)
	}
}
impl Deserialize {
	fn deserialize(v) -> bool {
		variant_to_bool(v)
	}
}
impl Serialize {
	fn serialize(v: int) {
		Int(v)
	}
}
impl Deserialize {
	fn deserialize(v) -> int {
		variant_to_int(v)
	}
}
impl Serialize {
	fn serialize(v: float) {
		Float(v)
	}
}
impl Deserialize {
	fn deserialize(v) -> float {
		variant_to_float(v)
	}
}
impl Serialize {
	fn serialize(v: string) {
		String(v)
	}
}
impl Deserialize {
	fn deserialize(v) -> string {
		variant_to_string(v)
	}
}

// Serde for arrays
impl Serialize {
	fn serialize(a) {
		let mut result = [];
		for i in range(0, array_len(a)) {
			array_append(result, serialize(a[i]));
		};
		Array(result)
	}
}
impl Deserialize {
	fn deserialize(a) {
		match (a) {
			Array(a) => {
				let mut result = [];
				for i in range(0, array_len(a)) {
					array_append(result, deserialize(a[i]));
				};
				result
			},
			_ => panic(f"Expected Array variant, got \"{a}\"")
		}
	}
}