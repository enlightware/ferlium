@tokens {
    Identifier { $[a-zA-Z_]$[a-zA-Z0-9_]* }
    Integer { $[0-9]$[0-9]* }
    String { 'f'? '"' (!["\\] | "\\" _)* '"' }
    BoolLiteral { "true" | "false" }
    LineComment[isolate] { "//" ![\n]* }
    BlockComment[isolate] { "/*" blockCommentRest }
    blockCommentRest { ![*] blockCommentRest | "*" blockCommentAfterStar }
    blockCommentAfterStar { "/" | "*" blockCommentAfterStar | ![/*] blockCommentRest }
    whitespace { @whitespace+ }
    CompareOp { "==" | "!="| ">"| ">="| "<" | "<=" }

    "[" "]" "{" "}" "(" ")"
    ";" ":" "::" ","
    "=" "=>" ".."

    @precedence { LineComment, BlockComment, "/" }
    @precedence { BoolLiteral, String, Identifier }
}

kw<term> { @specialize[@name={term}]<Identifier, term> }

@skip { whitespace | LineComment | BlockComment }

@top module {
    FunctionsOrTypes Expr
    | FunctionsOrTypes
    | Expr
}

FunctionsOrTypes {
    FunctionOrTypes { FunctionOrType+ }
}

FunctionOrType {
    Function
}

Function {
    kw<'fn'> Identifier '(' StringArgsOptComma ')' '{' Expr '}'
}

Expr {
    ArithExpression
    | LogicExpression
    | CompareExpression
    | Assignment
    | IfExpression
    | MatchExpression
    | ForExpression
    | !return kw<'return'> Expr
    | !parentheses '(' Expr ')'
    | Path
    | Literal
    | VarDefExpression
    | AbstractExpression
    | TupleExpression
    | RecordExpression
    | ProjectExpression
    | ArrayExpression
    | ApplyExpression
    | IndexExpression
    | Expr !semicolon ';' Expr
    | PropertyPath
}

ArithExpression {
    Expr !additive ArithOp { '+' | '-' } Expr
    | Expr !multiplicative ArithOp { '*' | '/' | '%'} Expr
    | !unaryMinus ArithOp { '-' } Expr
}

LogicExpression {
    Expr !or LogicOp { kw<'or'> } Expr
    | Expr !and LogicOp { kw<'and'>} Expr
    | !not kw<'not'> Expr
}

CompareExpression {
    Expr !compare CompareOp Expr
}

Assignment {
    Expr !equal '=' Expr
}

IfExpression {
	!command kw<'if'> Expr '{' Expr '}' kw<'else'> IfExpression
    | !command kw<'if'> Expr '{' Expr '}' (!command kw<'else'> '{' Expr '}')?
}

MatchExpression {
    !command kw<'match'> Expr '{' MatchArgsOptComma '}'
    | !command kw<'match'> Expr '{' MatchArgs ',' kw<'_'> '=>' ExprOptComma '}'
}

ForExpression {
    !command kw<'for'> Identifier kw<'in'> Expr '..' Expr '{' Expr '}'
}

VarDefExpression {
    !command kw<'let'> kw<'mut'>? Identifier '=' Expr
}

AbstractExpression {
    !vertical '|' StringArgsOptComma !vertical '|' Expr
}

TupleExpression {
    !parentheses '(' ')'
    | !parentheses '(' TupleArgs ')'
}

RecordExpression {
    !braces '{' RecordFieldsOptComma '}'
}

ProjectExpression {
    Expr !dot '.' Integer
    | Expr !dot '.' Identifier
}

ArrayExpression {
    !bracket '[' ']'
    | !bracket '[' ExprArgsOptComma ']'
}

ApplyExpression {
    Expr !parentheses '(' ')'
    | Expr '(' ExprArgsOptComma ')'
}

IndexExpression {
    Expr !bracket '[' Expr ']'
}

ExprOptComma {
    Expr ','
    | Expr
}

StringArgsOptComma {
    StringArgs ','
    | StringArgs
}

StringArgs {
    StringArgs ',' Identifier
    | Identifier
    | ""
}
ExprArgsOptComma {
    ExprArgs ','
    | ExprArgs
}

ExprArgs{
    ExprArgs ',' Expr
    | Expr
}

TupleArgs {
    Expr ',' ExprArgs
    | Expr ',' ExprArgs ','
    | Expr ','
}

RecordFieldsOptComma {
    RecordFields ','
    | RecordFields
}

RecordFields {
    RecordFields ',' 'Identifier' ':' Expr
    | Identifier ':' Expr
}

MatchArgsOptComma {
    MatchArgs ','
    | MatchArgs
}

MatchArgs {
    MatchArgs ',' MatchArg
    | MatchArg
}

MatchArg {
    Pattern '=>' Expr
}

Pattern {
    LiteralPattern
    | Identifier
    | Identifier '(' StringArgsOptComma ')'
}

LiteralPattern {
    Literal
}

PropertyPath {
	'@' Path '.' Identifier
}

Path {
    Identifier
    | Identifier '::' Path
}

Literal {
    Integer
    | String
    | BoolLiteral
}


@precedence {
    parentheses,
    dot @right,
    unaryMinus @right,
    multiplicative @left,
    additive @left,
    bracket,
    compare @left,
    not @right,
    and @left,
    or @left,
    vertical,
    equal @left,
    braces,
    logic @left,
    command,
    return,
    semicolon @left
}
