use crate::{SourceId, Location, LocatedError};
use crate::ast::{UstrSpan, Path, UseTree, PTypeSpan as TypeSpan, PMutTypeTypeSpan as MutTypeTypeSpan, PExpr as Expr, PExprKind as ExprKind, ExprKind::*, Pattern, PatternKind as PatK, PatternVar, PModuleFunctionArg as ModuleFunctionArg, PModule as Module, PModuleFunction as ModuleFunction, PTraitImpl as TraitImpl, PTypeDef as TypeDef, TypeAlias, PType as Type, PFnType as FnType, PFnArgType as FnArgType, PMutType as MutType, Attribute, MetaItem, UnnamedArg};
use crate::value::LiteralValue;
use crate::r#type::Type as IrType;
use crate::parser_helpers::*;
use crate::std::{math::int_type, string::string_type};
use crate::containers::{b as boxed, SVec2};
use crate::mutability::{MutVal};

use ustr::{Ustr, ustr};

use lalrpop_util::ErrorRecovery;

grammar<'err>(
    source_id: SourceId,
    errors: &'err mut Vec<ErrorRecovery<usize, Token<'input>, LocatedError>>
);

extern {
    type Error = LocatedError;
}

pub ModuleAndExpr: (Module, Option<Expr>) = {
    <m:Module> <e:Es<ExtraExpr>?> => (m, e),
}

pub ModuleAndBlockContent: (Module, Option<Expr>) = {
    <m:Module> <l:@L> <s:Stmts> <r:@R> => {
        if s.is_empty() {
            (m, None)
        } else {
            (m, Some(Expr::new(Block(s), span(l, r, source_id))))
        }
    },
    <m:Module> <l:@L> <s:Stmts> <e:Expr> <r:@R> => {
        (m, Some(Expr::new(Block(ext_b(s, e)), span(l, r, source_id))))
    },
}

ExtraExpr: ExprKind = {
    <e:Stmts> <r:Expr> => Block(ext_b(e, r)),
}

pub Module: Module = {
    ModuleItem* => {
        <>.into_iter().fold(Module::default(), |a, m| a.merge(m))
    }
}

ModuleItem = {
    ModuleFunction,
    ModuleTraitImpl,
    ModuleTypeDef,
    ModuleTypeAlias,
    ModuleUseDecl,
}

ModuleTraitImpl: Module = {
    TraitImpl => Module::single_impl(<>)
}

TraitImpl: TraitImpl = {
    <l:@L> "impl" <trait_name:Sp<UIdentifier>> "{" <functions:Function*> "}" <r:@R> => {
        TraitImpl {
            trait_name,
            functions,
            span: span(l, r, source_id),
        }
    }
}

ModuleFunction: Module = {
    Function => Module::single_function(<>)
}

ModuleTypeDef: Module = {
    TypeDefinition => Module::single_type_def(<>)
}

ModuleTypeAlias: Module = {
    TypeAliasDefinition => Module::single_type_alias(<>)
}

ModuleUseDecl: Module = {
    UseDeclaration => Module::uses_tree(<>)
}

UseDeclaration: UseTree = {
    "use" <u:UseTree> ";" => u
}

UseTree: UseTree = {
    <p:(<Path> "::")?> <w:Sp<"*">> => {
        UseTree::Glob(p, w.1)
    },
    <p:(<Path> "::")?> "{" <t:Sep<UseTree, ",">> "}" => {
        UseTree::Group(p, t)
    },
    // TODO: when needed, add "as" renaming support
    <p:Path> => {
        UseTree::Name(p)
    }
}

Function: ModuleFunction = {
    <doc:DOC_COMMENT?> <l:@L> "fn" <name:Sp<UIdentifier>> <al:@L> "(" <args:ModuleFunctionArgs> ")" <ret:SpFnRet<"P">?> <ar:@R> <body:Es<Block>> <r:@R> =>
        ModuleFunction::new(name, args, span(al, ar, source_id), ret, body, span(l, r, source_id), parse_doc_comments(doc)),
}

ModuleFunctionArgs: Vec<ModuleFunctionArg> = {
    <args:StrWithOptTypeArgs> => args.into_iter().map(|(name, ty)| {
        ModuleFunctionArg { name, ty }
    }).collect(),
}

// Type

pub DefinedType: Type = {
    Type<"", "R">
}

pub HoledType: Type = {
    Type<"P", "R">
}

Type<P, R>: Type = {
    PlaceholderType if P != "",
    PathType,
    ArrayType<P>,
    SetType<P>,
    MapType<P>,
    RecordType<P>,
    VariantType<P, R>,
    TupleOrFnType<P, R>,
}

TupleOrFnType<P, R>: Type = {
    "(" ")" => Type::Unit,
    "(" ")" <ret:EffFnRet<P>> => Type::function_type(FnType::new(vec![], ret.0, ret.1)),
    "(" <arg:ArgType<P, R>> ")" <ret:EffFnRet<P>?> =>?
        Ok(if let Some(ret) = ret {
            Type::function_type(FnType::new(vec![arg], ret.0, ret.1))
        } else if arg.mut_ty.is_some() {
            return error("types outside function arguments cannot be &mut".into(), arg.span);
        } else {
            arg.ty.0
        }),
    "(" <arg0:ArgType<P, R>> "," <args:Sep<ArgType<P, R>, ",">> ")" <ret:EffFnRet<P>?> =>?
    {
        let args = ext_f(arg0, args);
        Ok(if let Some(ret) = ret {
            Type::function_type(FnType::new(args, ret.0, ret.1))
        } else if let Some(arg) = args.iter().find(|a| a.mut_ty.is_some()) {
            return error("types outside function arguments cannot be &mut".into(), arg.span);
        } else {
            Type::Tuple(args.into_iter().map(|a| a.ty).collect::<Vec<_>>())
        })
    }
}

#[inline]
EffFnRet<P>: (TypeSpan, bool) = {
    "->" <ret:Sp<Type<P, "">>> if P != "" => (ret, true),
    "->" <ret:Sp<Type<P, "">>> if P == "" => (ret, false)
}

#[inline]
SpFnRet<P>: TypeSpan = {
    "->" <ret:Sp<Type<P, "">>> => ret
}

ArgType<P, R>: FnArgType = {
    <l:@L> "&" "mut" <t:Sp<Type<P, R>>> <r:@R> => FnArgType::new(t, Some(MutType::Mut), span(l, r, source_id)),
    <l:@L> "&" "?" <t:Sp<Type<P, R>>> <r:@R> if P !=  "" => FnArgType::new(t, Some(MutType::Infer), span(l, r, source_id)),
    <t:Sp<Type<P, R>>> => { let span = t.1; FnArgType::new(t, None, span) },
}

PlaceholderType: Type = {
    "_" => Type::Infer,
}

PathType: Type = {
    <p:Path> => Type::Path(p),
}

ArrayType<P>: Type = {
    "[" <t:Sp<Type<P, "">>> "]" => Type::Array(boxed(t))
}

SetType<P>: Type = {
    "{" <t:Sp<Type<P, "">>> "}" =>? error("set types not implemented yet".into(), t.1)
}

MapType<P>: Type = {
    "{" <k:Sp<Type<P, "">>> "=>" <v:Sp<Type<P, "">>> "}" =>? error("map types not implemented yet".into(), span_u32(k.1.start(), v.1.end(), source_id))
}

RecordType<P>: Type = {
    "{" <RecordTypeFields<P>> "}" => <>,
    "{" "}" => Type::Record(vec![])
}

RecordTypeFields<P>: Type = {
    <f:RecordTypeField<P>> => Type::Record(vec![f]),
    <f:RecordTypeField<P>> "," <r:Sep<RecordTypeField<P>, ",">> => Type::Record(ext_f(f, r)),
}

RecordTypeField<P>: (UstrSpan, TypeSpan) = {
    <n:Sp<UIdentifier>> ":" <t:Sp<Type<P, "">>> => (n, t),
}

VariantType<P, R>: Type = {
    <f:VariantTypeAlternative<P, "", R>> => Type::Variant(vec![f]),
    <f:VariantTypeAlternative<P, "U", R>> "|" <n:VariantTypeAlternative<P, "U", R>> <r:("|" <VariantTypeAlternative<P, "U", R>>)*> => Type::Variant(ext_f(f, ext_f(n, r))),
}

VariantTypeAlternative<P, U, R>: (UstrSpan, TypeSpan) = {
    <tag:Sp<UIdentifier>> if U != "" => (tag, (Type::Unit, tag.1)),
    <tag:Sp<UIdentifier>> <l:@L> "(" <args:Sep<Sp<Type<P, R>>, ",">> ")" <r:@R> => (tag, (Type::Tuple(args), span(l, r, source_id))),
    <tag:Sp<UIdentifier>> <l:@L> "{" <rec:RecordTypeFields<P>> "}" <r:@R> if R != "" => (tag, (rec, span(l, r, source_id))),
}

TypeAscription: TypeSpan = {
    ":" <ty:Sp<HoledType>> => ty,
}

RefMutTypeAscription: MutTypeTypeSpan = {
    ":" <l:@L> <ref_mut:("&" MutTyOrInfer)?> <ty:HoledType> <r:@R> => (ref_mut.map(|(_, m)| m), ty, span(l, r, source_id))
}

MutTyOrInfer: MutType = {
    "mut" => MutType::Mut,
    "?" => MutType::Infer,
}

// Type Definitions

TypeDefinition: TypeDef = {
    StructDefinition,
    EnumDefinition,
}

TypeAliasDefinition: TypeAlias = {
    <l:@L> "type" <name:Sp<UIdentifier>> "=" <ty:Sp<DefinedType>> <r:@R> ";" => {
        TypeAlias::new(name, ty)
    }
}

StructDefinition: TypeDef = {
    <l:@L> <attributes:(Attribute)*> "struct" <name:Sp<UIdentifier>> <generics:GenericParams?> <shape:StructBody> <r:@R> => {
        TypeDef {
            name,
            generic_params: generics.unwrap_or_default(),
            shape,
            attributes,
            span: span(l, r, source_id),
            doc_comments: vec![],
        }
    }
}

StructBody: Type = {
    "{" <fields:StructNamedFields?> "}" => Type::Record(fields.unwrap_or_default()),
    "(" <fields:StructTupleFields> ")" => Type::Tuple(fields),
    ";" => Type::Unit, // Unit struct
}

StructNamedFields: Vec<(UstrSpan, TypeSpan)> = {
    <f:StructNamedField> => vec![f],
    <f:StructNamedField> "," <r:StructNamedFields> => ext_f(f, r),
    <f:StructNamedField> "," => vec![f], // trailing comma
}

StructNamedField: (UstrSpan, TypeSpan) = {
    <field:RecordTypeField<"">> => <>,
}

StructTupleFields: Vec<TypeSpan> = {
    <t:Sp<DefinedType>> => vec![t],
    <t:Sp<DefinedType>> "," <r:StructTupleFields> => ext_f(t, r),
    <t:Sp<DefinedType>> "," => vec![t], // trailing comma
}

EnumDefinition: TypeDef = {
    <l:@L> <attributes:(Attribute)*> "enum" <name:Sp<UIdentifier>> <generics:GenericParams?> "{" "}" <r:@R> => {
        TypeDef {
            name,
            generic_params: generics.unwrap_or_default(),
            shape: Type::Never,
            attributes,
            span: span(l, r, source_id),
            doc_comments: vec![],
        }
    },
    <l:@L> <attributes:(Attribute)*> "enum" <name:Sp<UIdentifier>> <generics:GenericParams?> "{" <variants:EnumVariants> "}" <r:@R> => {
        let variant_ty = Type::Variant(variants);
        TypeDef {
            name,
            generic_params: generics.unwrap_or_default(),
            shape: variant_ty,
            attributes,
            span: span(l, r, source_id),
            doc_comments: vec![],
        }
    }
}

Attribute: Attribute = {
    <l:@L> "#[" <path:Sp<UIdentifier>> <items:AttrMetaList?> "]" <r:@R> => {
        let items = items.unwrap_or_default();
        Attribute {
            path,
            items,
            span: span(l, r, source_id)
        }
    }
}

AttrMetaList: Vec<MetaItem> = {
    "(" <items:AttrMetaItems> ")" => items,
}

AttrMetaItems: Vec<MetaItem> = {
    <item:AttrMetaItem> => vec![item],
    <item:AttrMetaItem> "," <r:AttrMetaItems> => ext_f(item, r),
    <item:AttrMetaItem> "," => vec![item], // trailing comma
}

AttrMetaItem: MetaItem = {
    // bare identifier flag
    <id:Sp<UIdentifier>> => MetaItem::Flag(id),
    // identifier = string value
    <l:@L> <key:Sp<UIdentifier>> "=" <value:Sp<UString>> <r:@R> => {
        MetaItem::NameValue { key, value, span: span(l, r, source_id) }
    }
}

EnumVariants: Vec<(UstrSpan, TypeSpan)> = {
    <v:EnumVariant> => vec![v],
    <v:EnumVariant> "," <r:EnumVariants> => ext_f(v, r),
    <v:EnumVariant> "," => vec![v], // trailing comma
}

EnumVariant: (UstrSpan, TypeSpan) = {
    // Unit variant: Name
    <name:Sp<UIdentifier>> => (name, (Type::Unit, name.1)),

    // Tuple variant with single type: Name(Type)
    <name:Sp<UIdentifier>> <l:@L> "(" <ty:Sp<DefinedType>> ")" <r:@R> => (name, (Type::Tuple(vec![ty]), span(l, r, source_id))),

    // Tuple variant with multiple types: Name(Type1, Type2, ...)
    <name:Sp<UIdentifier>> <l:@L> "(" <f:Sp<DefinedType>> "," <rest:Sep<Sp<DefinedType>, ",">> ")" <r:@R> => {
        let tys = ext_f(f, rest);
        let tuple_ty = Type::Tuple(tys);
        (name, (tuple_ty, span(l, r, source_id)))
    },

    // Record variant: Name { field1: Type1, field2: Type2, ... }
    <name:Sp<UIdentifier>> <ty:Sp<RecordType<"">>> => {
        (name, ty)
    },
}

GenericParams: Vec<UstrSpan> = {
    "<" <params:GenericParamList?> ">" => params.unwrap_or_default(),
}

GenericParamList: Vec<UstrSpan> = {
    <p:Sp<UIdentifier>> => vec![p],
    <p:Sp<UIdentifier>> "," <r:GenericParamList> => ext_f(p, r),
    <p:Sp<UIdentifier>> "," => vec![p], // trailing comma
}


// Expressions

// Expressions inspired from Rust: https://doc.rust-lang.org/reference/expressions.html
// Also: https://github.com/bleibig/rust-grammar/blob/master/parser-lalr.y
// Also: https://github.com/nikomatsakis/rustypop/blob/master/src/rusty.lalrpop

// TODO: add Rust-style optional semicolons in block expressions using
// the guard macro features of lalrpop as in Niko's rustypop.

pub Expr = {
    Es<TopExpr<"">>
}

TopExpr<NoStruct> = {
    AssignExpr<NoStruct>,
    ReturnExpr<NoStruct>,
    AbstractExpr<NoStruct>,
    PipeExpr<NoStruct>,
}

AssignExpr<NoStruct>: ExprKind = {
    <le:Es<PipeExpr<NoStruct>>> <ls:@L> "=" <rs:@R> <re:Es<TopExpr<NoStruct>>> => Assign(boxed(le), span(ls, rs, source_id), boxed(re)),
    <le:Es<PipeExpr<NoStruct>>> <ls:@L> <op:Sp<OpEqual>> <rs:@R> <re:Es<TopExpr<NoStruct>>> => assign_op(op.0, op.1, le, re),
}

ReturnExpr<NoStruct>: ExprKind = {
    "return" <e:Es<TopExpr<NoStruct>>> => Return(boxed(e)),
}

AbstractExpr<NoStruct>: ExprKind = {
    "|" <args:StrArgs> "|" <body:Es<TopExpr<NoStruct>>> => Abstract(args, boxed(body)),
    "||" <body:Es<TopExpr<NoStruct>>> => Abstract(vec![], boxed(body)),
}

PipeExpr<NoStruct>: ExprKind = {
    <l:Es<PipeExpr<NoStruct>>> "|>" <e:Es<SuffixExpr<"">>> "(" <a:Sep<Es<TopExpr<"">>, ",">> ")" => Apply(boxed(e), ext_f(l, a), UnnamedArg::First),
    RangeExpr<NoStruct>,
}

RangeExpr<NoStruct>: ExprKind = {
    <l:Es<UnaryExpr<NoStruct>>> <o:Sp<RangeOp>> <r:Es<UnaryExpr<NoStruct>>> => build_range(o.0, o.1, l, r),
    LogicOrExpr<NoStruct>,
}

LogicOrExpr<NoStruct>: ExprKind = {
    <l:Es<LogicOrExpr<NoStruct>>> <o:Sp<LogicalOrOp>> <r:Es<LogicAndExpr<NoStruct>>> => cond_if_else(l, literal_expr(true, o.1), r),
    LogicAndExpr<NoStruct>,
}

LogicAndExpr<NoStruct>: ExprKind = {
    <l:Es<LogicAndExpr<NoStruct>>> <o:Sp<LogicalAndOp>> <r:Es<CompExpr<NoStruct>>> => cond_if_else(l, r, literal_expr(false, o.1)),
    CompExpr<NoStruct>,
}

CompExpr<NoStruct> = BinOpLeftAssoc<CompOp, AddExpr<NoStruct>>;

AddExpr<NoStruct> = BinOpLeftAssoc<AddOp, MulExpr<NoStruct>>;

MulExpr<NoStruct> = BinOpLeftAssoc<MulOp, CastExpr<NoStruct>>;

CastExpr<NoStruct>: ExprKind = {
    <e:Es<CastExpr<NoStruct>>> <l:@L> "as" <ty:Sp<CastTargetType>> <r:@R> => {
        let e_span = e.span;
        let cast_expr = Expr::new(
            Identifier(Path::single_str("cast", e_span)),
            span(l, r, source_id)
        );
        TypeAscription(
            boxed(Expr::new(
                Apply(boxed(cast_expr), vec![e], UnnamedArg::All),
                e_span
            )),
            ty.0,
            ty.1
        )
    },
    UnaryExpr<NoStruct>,
}

// Cast target types: only allow simple, unambiguous types
// For complex types like tuples or functions, use parentheses: (value as (A, B))
CastTargetType: Type = {
    PathType,
    CastTargetTypeParens,
    ArrayType<"">,
    RecordType<"">,
}

CastTargetTypeParens: Type = {
    "(" <ty:DefinedType> ")" => ty
}

UnaryExpr<NoStruct> = {
    SuffixExpr<NoStruct>,
    <o:Sp<UnaryOp>> <e:Es<UnaryExpr<NoStruct>>> => syn_static_apply_path(o.0, o.1, vec![e]),
}

SuffixExpr<NoStruct> = {
    AtomExpr<NoStruct>,
    <e:Es<SuffixExpr<NoStruct>>> "." <f:Sp<UIdentifier>> => FieldAccess(boxed(e), f),
    <e:Es<SuffixExpr<NoStruct>>> "." <i:Sp<UIntValue>> =>? proj_or_float(e, i),
    <e:Es<SuffixExpr<NoStruct>>> "[" <i:Expr> "]" => Index(boxed(e), boxed(i)),
    <e:Es<SuffixExpr<NoStruct>>> "(" <a:Sep<Es<TopExpr<"">>, ",">> ")" => Apply(boxed(e), a, UnnamedArg::None),
}

AtomExpr<NoStruct> = {
    ParExpr,
    PathOrStructExpr<NoStruct>,
    PropertyPathExpr,
    LiteralExpr,
    FormattedString,
    TupleExpr,
    ArrayExpr,
    RecordExpr,
    SoftBreakExpr,
    StmtLikeExpr,
    BrokenExpr,
}

StmtLikeExpr = {
    IfExpr,
    MatchExpr,
    ForExpr,
    LoopExpr,
    Block,
}

ParExpr: ExprKind = {
    "(" <e:Expr> <ty:TypeAscription> ")" => TypeAscription(boxed(e), ty.0, ty.1),
    "(" <e:Expr> ")" => e.kind,
}

PathOrStructExpr<NoStruct>: ExprKind = {
    <p:Path> => Identifier(p),
    <p:Path> <body:StructExprImpl> if NoStruct != "NoStruct" => StructLiteral(p, body),
    <p:Path> "{" "}" if NoStruct != "NoStruct" => StructLiteral(p, vec![]),
}

PropertyPathExpr: ExprKind = {
    <p:PropertyPath> => PropertyPath(p.0, p.1),
}

#[inline]
Path: Path = {
    <p:PathSegments> => Path::new(p),
}

PathSegments: Vec<UstrSpan> = {
    Sp<PathIdentifier<"">> => vec![<>],
    <p:PathSegments> "::" <e:Sp<PathIdentifier<"E">>> => ext_b(p, e),
}

PathIdentifier<E>: Ustr = {
    UIdentifier => <>,
    "and" if E != "" => ustr("and"),
    "or" if E != "" => ustr("or"),
    "not" if E != "" => ustr("not"),
}

ForExpr: ExprKind = {
    "for" <id:Sp<UIdentifier>> "in" <seq:Es<TopExpr<"NoStruct">>> <body:Es<Block>> =>
        for_loop(id, seq, body),
}

IfExpr: ExprKind = {
    "if" <c:Es<TopExpr<"NoStruct">>> <t:Es<Block>> "else" <f:Es<IfExpr>> => cond_if_else(c, t, f),
    "if" <c:Es<TopExpr<"NoStruct">>> <t:Es<Block>> "else" <f:Es<Block>> => cond_if_else(c, t, f),
    "if" <c:Es<TopExpr<"NoStruct">>> <t:Es<Block>> => cond_if(c, t),
}

MatchExpr: ExprKind = {
    "match" <e:Es<TopExpr<"NoStruct">>> "{" <m:Sep<MatchArg, ",">> "}" =>
        Match(boxed(e), m, None),
    "match" <e:Es<TopExpr<"NoStruct">>> "{" <m:(<MatchArg> ",")*> "_" "=>" <d:Expr> ","? "}" =>
        Match(boxed(e), m, Some(boxed(d))),
}

MatchArg: (Pattern, Expr) = {
    <p:Pattern> "=>" <e:Expr> => (p, e),
}

Pattern: Pattern = {
    Ps<NullaryVariantPattern>,
    Ps<NAryVariantPattern>,
    Ps<StructVariantPattern>,
    Ps<LiteralPatternKind>,
}

NullaryVariantPattern: PatK = {
    Sp<UIdentifier> => PatK::empty_tuple_variant(<>),
}

NAryVariantPattern: PatK = {
    <tag:Sp<UIdentifier>> "(" <vars:StrOrMoreArgs> ")" => PatK::tuple_variant(tag, vars),
}

StructVariantPattern: PatK = {
    <tag:Sp<UIdentifier>> "{" <vars:StrOrMoreArgs> "}" => PatK::struct_variant(tag, vars),
}

LiteralPatternKind: PatK = {
    LiteralPattern => PatK::Literal(<>.0, <>.1),
}

LiteralPattern = {
    ScalarLiteralPattern,
    TupleLiteralPattern,
    // TODO: add RecordLiteralPattern
    // TODO: add ArrayLiteralPattern
}

ScalarLiteralPattern: (LiteralValue, IrType) = {
    LiteralValue => <>,
    // This is necessary as our IntLiteral parses only unsigned
    "-" <v:IntValue> => (literal_value(-v).0, int_type())
    // TODO: add float literal pattern
}

TupleLiteralPattern: (LiteralValue, IrType) = {
    "(" <f:LiteralPattern> "," <r:Sep<LiteralPattern, ",">> ")" => {
        let (vals, tys): (SVec2<_>, Vec<_>) = ext_f(f, r).into_iter().unzip();
        let val = LiteralValue::new_tuple(vals);
        let ty = IrType::tuple(tys);
        (val, ty)
    },
}

LiteralExpr: ExprKind = {
    LiteralValue => Literal(<>.0.into_value(), <>.1),
}

LiteralValue = {
    UnitLiteral,
    BoolLiteral,
    IntLiteral,
    // Note: floats are not here because their grammar conflict with projections.
    StringLiteral,
};

TupleExpr: ExprKind = {
    "(" <a:TupleArgs> ")" => tuple(a),
}

// Note: we need this to make the difference between a parenthesized expression
// and a tuple with a single element
TupleArgs: Vec<Expr> = {
    <f:Expr> "," <r:Sep<Expr, ",">> => ext_f(f, r),
}

ArrayExpr: ExprKind = {
    "[" <a:Sep<Expr, ",">> "]" => Array(a),
}

RecordExpr: ExprKind = {
    <r:RecordExprImpl> => Record(r),
}

// Records with support for field abbreviation syntax.
// For a single abbreviated field (e.g., {a}), a trailing comma is required ({a,})
// to distinguish from a block returning a value.
// For explicit field syntax (e.g., {a: 1}), no trailing comma is needed.
RecordExprImpl: Vec<(UstrSpan, Expr)> = {
    // Single explicit field: {a: 1}
    "{" <f:RecordExplicitField> "}" => vec![f],
    // Single abbreviated field with trailing comma: {a,}
    "{" <f:RecordAbbrevField> "," "}" => vec![f],
    // Multiple fields starting with explicit: {a: 1, ...}
    "{" <f:RecordExplicitField> "," <r:Sep<RecordField, ",">> "}" => ext_f(f, r),
    // Multiple fields starting with abbreviated: {a, ...} (at least one more field required)
    "{" <f:RecordAbbrevField> "," <s:RecordField> <r:("," <RecordField>)*> ","? "}" => ext_f(f, ext_f(s, r)),
}

RecordField: (UstrSpan, Expr) = {
    RecordExplicitField,
    RecordAbbrevField,
}

RecordExplicitField: (UstrSpan, Expr) = {
    <n:Sp<UIdentifier>> ":" <e:Expr> => (n, e),
}

RecordAbbrevField: (UstrSpan, Expr) = {
    <n:Sp<UIdentifier>> => (n, Expr::new(Identifier(Path::single_tuple(n)), n.1)),
}

// Struct literals support both explicit and shorthand field syntax
StructExprImpl: Vec<(UstrSpan, Expr)> = {
    "{" <f:StructField> "}" => vec![f],
    "{" <f:StructField> "," <r:Sep<StructField, ",">> "}" => ext_f(f, r),
}

StructField: (UstrSpan, Expr) = {
    // Explicit field assignment: field_name: expression
    <n:Sp<UIdentifier>> ":" <e:Expr> => (n, e),
    // Shorthand syntax: field_name (equivalent to field_name: field_name)
    <n:Sp<UIdentifier>> => (n, Expr::new(Identifier(Path::single_tuple(n)), n.1)),
}

PropertyPath: (Path, Ustr) = {
    "@" <p:Path> "." <f:UIdentifier> => (p, f),
}

LoopExpr: ExprKind = {
    "loop" <b:Es<Block>> => Loop(boxed(b)),
}

SoftBreakExpr: ExprKind = {
    "soft_break" => SoftBreak,
}

Block: ExprKind = {
    "{" <e:Stmts> <r:Expr> "}" => Block(ext_b(e, r)),
    "{" <e:Stmts> <r:Loc<"}">> => Block(ext_b(e, unit_literal_expr(r))),
}

#[inline]
Stmts = { Stmt* }

Stmt = {
    Es<LetStmt>,
    ExprStmt,
}

LetStmt: ExprKind = {
    "let" <mut_flag:"mut"?> <id:Sp<UIdentifier>> <ty:TypeAscription?> "=" <e:Expr> ";" => {
        let mut_val = if mut_flag.is_some() {
            MutVal::mutable()
        } else {
            MutVal::constant()
        };
        let (e, ty_span_and_complete) = if let Some((ty, ty_span)) = ty {
            let span = e.span;
            (
                Expr::new(TypeAscription(boxed(e), ty, ty_span), span),
                Some((ty_span, ()))
            )
        } else {
            (e, None)
        };
        Let(id, mut_val, boxed(e), ty_span_and_complete)
    }
}

ExprStmt: Expr = {
    <e:Expr> ";" => e,
}

// Error recovery

BrokenExpr: ExprKind = {
    ! => { errors.push(<>); Error },
}

// Common non-terminals

// String arguments with optional trailing comma
StrArgs = {
    Sep<Sp<UIdentifier>, ",">
}

StrWithOptTypeArgs = {
    Sep<StrWithOptType, ",">
}

StrWithOptType: (UstrSpan, Option<MutTypeTypeSpan>) = {
    <id:Sp<UIdentifier>> <ty:RefMutTypeAscription?> => (id, ty),
}

StrOrMoreArgs = {
    Sep<StrOrMore, ",">,
}

StrOrMore: PatternVar = {
    <id:Sp<UIdentifier>> => PatternVar::Named(id),
    <l:@L> ".." <r:@R> => PatternVar::Wildcard(span(l, r, source_id)),
}

// Terminals

RangeOp: Vec<&'static str> = {
    ".." => vec!["std", "Range"],
    "..=" => vec!["std", "RangeInclusive"],
}

UnaryOp: Vec<&'static str> = {
    "-" => vec!["std", "neg"],
    "not" => vec!["std", "not"],
    <l:@L> "!" <r:@R> =>? error("for readability, use the \"not\" keyword instead of the C-style ! operator".into(), span(l, r, source_id)),
}

MulOp: Vec<&'static str> = {
    "*" => vec!["std", "mul"],
    "/" => vec!["std", "div"],
}

AddOp: Vec<&'static str> = {
    "+" => vec!["std", "add"],
    "-" => vec!["std", "sub"],
}

CompOp: Vec<&'static str> = {
    "==" => vec!["std", "eq"],
    "!=" => vec!["std", "ne"],
    "<=" => vec!["std", "le"],
    "<" => vec!["std", "lt"],
    ">=" => vec!["std", "ge"],
    ">" => vec!["std", "gt"],
}

LogicalAndOp: () = {
    "and" => (),
    <l:@L> "&&" <r:@R> =>? error("for readability, use the \"and\" keyword instead of the C-style && operator".into(), span(l, r, source_id)),
}

LogicalOrOp: () = {
    "or" => (),
    <l:@L> "||" <r:@R> =>? error("for readability, use the \"or\" keyword instead of the C-style || operator".into(), span(l, r, source_id)),
}

UIdentifier: Ustr = {
    Identifier => ustr(<>),
}

Identifier: &'input str = r"[\p{L}_][\p{L}\p{N}_]*" => <>;

UnitLiteral: (LiteralValue, IrType) = {
    "(" ")" => literal_value(())
}

BoolLiteral: (LiteralValue, IrType) = {
    "true" => literal_value(true),
    "false" => literal_value(false),
};

IntLiteral: (LiteralValue, IrType) = {
    IntValue => literal_value(<>),
};

IntValue: isize = <l:@L> <s:r"[1-9][0-9]*|0"> <r:@R> =>? match parse_num::<isize>(s) {
    Ok(value) => Ok(value),
    Err(msg) => error(msg, span(l, r, source_id)),
};

UIntValue: usize = <l:@L> <s:r"[1-9][0-9]*|0"> <r:@R> =>? match parse_num::<usize>(s) {
    Ok(value) => Ok(value),
    Err(msg) => error(msg, span(l, r, source_id)),
};

StringLiteral: (LiteralValue, IrType) = StringToken => (string_literal(<>), string_type());

UString: Ustr = StringToken => ustr(&parse_string(<>));

StringToken: &'input str = r#"\"([^\\\"]|\\.)*\""# => <>;

FormattedString: ExprKind = r#"f\"([^\\\"]|\\.)*\""# => formatted_string(<>);

OpEqual: Vec<&'static str> = {
    "+=" => vec!["std", "add"],
    "-=" => vec!["std", "sub"],
    "*=" => vec!["std", "mul"],
    "/=" => vec!["std", "div"],
}

// Macros

// Build an Expr out of an ExprKind by adding its span
#[inline]
Es<K>: Expr = {
    Sp<K> => Expr::new(<>.0, <>.1),
};

// Build a Pattern out of an PatternKind by adding its span
#[inline]
Ps<T>: Pattern = {
    Sp<T> => Pattern::new(<>.0, <>.1),
};

// Return T along with its location
Sp<T>: (T, Location) = {
    <l:@L> <t: T> <r:@R> => (t, span(l, r, source_id)),
};

// Return the location of T, ignoring its content
Loc<T>: Location = {
    <l:@L> T <r:@R> => span(l, r, source_id),
};

// S-separated list of T, with optional trailing S
Sep<T, S>: Vec<T> = {
    <mut v:(<T> S)*> <e:T?> => match e {
        None => v,
        Some(e) => {
            v.push(e);
            v
        }
    }
};

// A tier of expression, for a binary operation, left-associative
#[inline]
BinOpLeftAssoc<Op, NextTier>: ExprKind = {
    <l:Es<BinOpLeftAssoc<Op, NextTier>>> <o:Sp<Op>> <r:Es<NextTier>> => syn_static_apply_path(o.0, o.1, vec![l, r]),
    NextTier
};

// Skip whitespaces and comments in the lexer
match {
    r"///[^\n\r]*[\n\r]*" => DOC_COMMENT,
} else {
    r"\s*" => { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" => { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" => { },  // Skip `/* comments */`
    _
}